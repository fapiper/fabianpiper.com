name: Build and Push Docker Images

on:
  push:
    branches: [ main ]
    paths:
      - 'apps/**'
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      apps: ${{ steps.set-matrix.outputs.apps }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - id: set-matrix
        run: |
          set -euo pipefail
          BASE_SHA=${{ github.event.before }}
          [ "$BASE_SHA" = "0000000000000000000000000000000000000000" ] && BASE_SHA="HEAD^"
          DIFF=$(git diff --name-only $BASE_SHA ${{ github.sha }} | grep '^apps/' | cut -d/ -f2 | sort -u || true)
          if [ -z "$DIFF" ]; then
            echo "apps=[]" >> $GITHUB_OUTPUT
          else
            APPS_JSON=$(echo "$DIFF" | jq -R -s -c 'split("\n") | map(select(length > 0))')
            echo "apps=$APPS_JSON" >> $GITHUB_OUTPUT
          fi

  build-and-push:
    needs: detect-changes
    if: needs.detect-changes.outputs.apps != '[]'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    strategy:
      matrix:
        app: ${{ fromJSON(needs.detect-changes.outputs.apps) }}

    steps:
      - uses: actions/checkout@v4

      - uses: nhedger/setup-sops@v2

      - name: Decrypt Bootstrap Secrets
        env:
          SOPS_AGE_KEY: ${{ secrets.SOPS_AGE_KEY }}
        run: |
          set -euo pipefail
          mkdir -p secrets
          echo "$SOPS_AGE_KEY" > secrets/.sops.key
          export SOPS_AGE_KEY_FILE=$(pwd)/secrets/.sops.key
          
          # Entschlüsseln
          sops -d --output-type dotenv secrets/prod/secrets.yaml > secrets.env
          
          # Sanity Check: Existiert die Datei und hat sie Inhalt?
          if [ ! -s secrets.env ]; then echo "ERROR: secrets.env is empty or not found"; exit 1; fi
          
          # Maskieren
          while IFS='=' read -r key value; do
            [ -n "$value" ] && echo "::add-mask::${value}"
          done < secrets.env

      - name: Configure OCI CLI
        run: |
          set -euo pipefail
          # Variablen in die Shell laden
          set -a && source secrets.env && set +a
          
          mkdir -p ~/.oci
          
          # FIX 1: Den Key absolut sicher schreiben (tr löscht Windows-Zeilenenden)
          printf "%s" "$TF_VAR_private_key_content" | tr -d '\r' > ~/.oci/key.pem
          chmod 600 ~/.oci/key.pem
          
          # FIX 2: Check ob der Key mit dem richtigen Header beginnt
          if ! head -n 1 ~/.oci/key.pem | grep -q "BEGIN"; then
            echo "ERROR: Key file does not start with BEGIN header. Check your SOPS secret format."
            exit 1
          fi
          
          # FIX 3: Config schreiben (KEINE Einrückung beim EOF!)
          cat <<EOF > ~/.oci/config
  [DEFAULT]
  user=$TF_VAR_user_ocid
  fingerprint=$TF_VAR_fingerprint
  tenancy=$TF_VAR_tenancy_ocid
  region=$TF_VAR_region
  key_file=$HOME/.oci/key.pem
  EOF
  chmod 600 ~/.oci/config
  
  echo "OCI_COMPARTMENT_ID=$TF_VAR_compartment_ocid" >> $GITHUB_ENV

- uses: oracle-actions/run-oci-cli-command@v1.3.2
  with:
    command: "--version"
    silent: true

- name: Resolve Vault Secrets
  id: vault_secrets
  run: |
    set -euo pipefail
    
    # OCI Login Test
    oci iam compartment get --compartment-id "$OCI_COMPARTMENT_ID" > /dev/null || (echo "ERROR: OCI Login failed or Compartment ID invalid" && exit 1)
    
    echo "Fetching secrets..."
    SECRETS_JSON=$(oci vault secret list --compartment-id "$OCI_COMPARTMENT_ID" --all --lifecycle-state ACTIVE --query "data[*].{name: \"secret-name\", id: id}")
    
    if [ "$SECRETS_JSON" = "[]" ] || [ -z "$SECRETS_JSON" ]; then
      echo "::warning::No secrets found"
      echo "build_args=" >> $GITHUB_OUTPUT
      exit 0
    fi
    
    {
      echo "build_args<<EOF_BUILD_ARGS"
      while read -r secret; do
        V_NAME=$(echo "$secret" | jq -r '.name')
        V_ID=$(echo "$secret" | jq -r '.id')
        [ "$V_NAME" = "null" ] && continue
    
        ARG_NAME=$(echo "$V_NAME" | tr '-' '_' | tr '[:lower:]' '[:upper:]')
    
        BUNDLE=$(oci secrets secret-bundle get --secret-id "$V_ID" --stage CURRENT 2>/dev/null)
        VALUE=$(echo "$BUNDLE" | jq -r '.data."secret-bundle-content".content' | base64 -d 2>/dev/null)
    
        if [ -n "$VALUE" ]; then
          echo "::add-mask::${VALUE}"
          echo "${ARG_NAME}=${VALUE}"
        fi
      done < <(echo "$SECRETS_JSON" | jq -c '.[]')
    
      echo "EOF_BUILD_ARGS"
    } >> $GITHUB_OUTPUT

- uses: docker/setup-buildx-action@v3

- uses: docker/login-action@v3
  with:
    registry: ${{ env.REGISTRY }}
    username: ${{ github.actor }}
    password: ${{ secrets.GITHUB_TOKEN }}

- uses: docker/build-push-action@v6
  with:
    context: apps/${{ matrix.app }}
    push: true
    tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/${{ matrix.app }}:latest
    build-args: ${{ steps.vault_secrets.outputs.build_args }}

- name: Cleanup
  if: always()
  run: rm -rf secrets.env secrets/ ~/.oci/