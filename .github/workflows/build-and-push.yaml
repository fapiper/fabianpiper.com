name: Build and Push Docker Images

on:
  push:
    branches: [main]
    paths:
      - "apps/**"
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      apps: ${{ steps.set-matrix.outputs.apps }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - id: set-matrix
        run: |
          set -euo pipefail

          BASE_SHA="${{ github.event.before }}"
          HEAD_SHA="$GITHUB_SHA"

          # Fallback for first push or manual trigger (no before SHA)
          if [ "$BASE_SHA" = "0000000000000000000000000000000000000000" ] || [ -z "$BASE_SHA" ]; then
            BASE_SHA="HEAD^"
          fi

          # Validate SHA is safe before using in git command
          if ! echo "$BASE_SHA" | grep -qE '^[0-9a-f]{40}$|^HEAD\^$'; then
            echo "::error::Unexpected BASE_SHA format: $BASE_SHA"
            exit 1
          fi

          DIFF=$(git diff --name-only -- "$BASE_SHA" "$HEAD_SHA" \
            | grep '^apps/' \
            | cut -d/ -f2 \
            | sort -u \
            || true)

          if [ -z "$DIFF" ]; then
            echo "apps=[]" >> "$GITHUB_OUTPUT"
          else
            SAFE_APPS=""
            while IFS= read -r app; do
              if echo "$app" | grep -qE '^[a-zA-Z0-9_-]+$'; then
                SAFE_APPS="${SAFE_APPS}${app}"$'\n'
              else
                echo "::warning::Skipping app with unsafe name: $app"
              fi
            done <<< "$DIFF"

            if [ -z "$SAFE_APPS" ]; then
              echo "apps=[]" >> "$GITHUB_OUTPUT"
            else
              APPS_JSON=$(echo "$SAFE_APPS" | jq -R -s -c 'split("\n") | map(select(length > 0))')
              echo "apps=$APPS_JSON" >> "$GITHUB_OUTPUT"
            fi
          fi

  build-and-push:
    needs: detect-changes
    if: needs.detect-changes.outputs.apps != '[]' && needs.detect-changes.outputs.apps != ''
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    strategy:
      matrix:
        app: ${{ fromJSON(needs.detect-changes.outputs.apps) }}

    steps:
      - uses: actions/checkout@v4

      - uses: nhedger/setup-sops@v2

      - name: Decrypt SOPS Secrets
        env:
          SOPS_AGE_KEY: ${{ secrets.SOPS_AGE_KEY }}
        run: |
          set -euo pipefail

          TMPKEY=$(mktemp)
          trap 'rm -f "$TMPKEY"' EXIT
          echo "$SOPS_AGE_KEY" > "$TMPKEY"
          export SOPS_AGE_KEY_FILE="$TMPKEY"

          SECRETS_JSON=$(sops -d --output-type json secrets/prod/secrets.yaml)

          OCI_USER=$(echo "$SECRETS_JSON" | jq -r '.TF_VAR_user_ocid')
          OCI_TENANCY=$(echo "$SECRETS_JSON" | jq -r '.TF_VAR_tenancy_ocid')
          OCI_FINGERPRINT=$(echo "$SECRETS_JSON" | jq -r '.TF_VAR_fingerprint')
          OCI_REGION=$(echo "$SECRETS_JSON" | jq -r '.TF_VAR_region')
          OCI_COMPARTMENT=$(echo "$SECRETS_JSON" | jq -r '.TF_VAR_compartment_ocid')
          OCI_PRIVATE_KEY=$(echo "$SECRETS_JSON" | jq -r '.TF_VAR_private_key_content' | tr -d '\r')

          echo "::add-mask::$OCI_USER"
          echo "::add-mask::$OCI_TENANCY"
          echo "::add-mask::$OCI_FINGERPRINT"

          while IFS= read -r line; do
            [ -n "$line" ] && echo "::add-mask::$line"
          done <<< "$OCI_PRIVATE_KEY"

          mkdir -p ~/.oci
          echo "$OCI_PRIVATE_KEY" > ~/.oci/key.pem
          chmod 600 ~/.oci/key.pem

          cat > ~/.oci/config <<EOF
          [DEFAULT]
          user=$OCI_USER
          fingerprint=$OCI_FINGERPRINT
          tenancy=$OCI_TENANCY
          region=$OCI_REGION
          key_file=$HOME/.oci/key.pem
  EOF
  chmod 600 ~/.oci/config
  
  echo "OCI_COMPARTMENT_ID=$OCI_COMPARTMENT" >> "$GITHUB_ENV"
  
  unset SECRETS_JSON OCI_PRIVATE_KEY

- name: Resolve Vault Secrets
  id: vault_secrets
  run: |
    set -euo pipefail
    
    VAULT_SECRETS=$(oci vault secret list \
      --compartment-id "$OCI_COMPARTMENT_ID" \
      --all \
      --lifecycle-state ACTIVE \
      --query "data[].{name: \"secret-name\", id: id}" \
      2>/dev/null)
    
    {
      echo "secret_envs<<EOF_SECRETS"
    
      if [ -n "$VAULT_SECRETS" ] && [ "$VAULT_SECRETS" != "[]" ]; then
        while IFS= read -r secret; do
          NAME=$(echo "$secret" | jq -r '.name')
          ID=$(echo "$secret" | jq -r '.id')
    
          # Validate secret name is safe
          if ! echo "$NAME" | grep -qE '^[a-zA-Z0-9_-]+$'; then
            echo "::warning::Skipping secret with unsafe name: $NAME"
            continue
          fi
    
          BUNDLE=$(oci secrets secret-bundle get --secret-id "$ID" --stage CURRENT 2>/dev/null) || {
            echo "::warning::Could not fetch secret: $NAME" >&2
            continue
          }
    
          VAL=$(echo "$BUNDLE" | jq -r '.data."secret-bundle-content".content' | base64 -d 2>/dev/null) || {
            echo "::warning::Could not decode secret: $NAME" >&2
            continue
          }
    
          if [ -n "$VAL" ]; then
            while IFS= read -r line; do
              [ -n "$line" ] && echo "::add-mask::$line"
            done <<< "$VAL"
    
            ARG_NAME=$(echo "$NAME" | tr '-' '_' | tr '[:lower:]' '[:upper:]')
            echo "${ARG_NAME}=${VAL}"
          fi
        done < <(echo "$VAULT_SECRETS" | jq -c '.[]')
      fi
    
      echo "SITE_URL=https://glg.fabianpiper.com"
      echo "EOF_SECRETS"
    } >> "$GITHUB_OUTPUT"

- uses: docker/setup-buildx-action@v3

- uses: docker/login-action@v3
  with:
    registry: ${{ env.REGISTRY }}
    username: ${{ github.actor }}
    password: ${{ secrets.GITHUB_TOKEN }}

- name: Build and Push
  uses: docker/build-push-action@v6
  with:
    context: apps/${{ matrix.app }}
    push: true
    tags: |
      ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/${{ matrix.app }}:latest
      ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/${{ matrix.app }}:${{ github.sha }}
    secrets: ${{ steps.vault_secrets.outputs.secret_envs }}
    cache-from: type=gha
    cache-to: type=gha,mode=max

- name: Cleanup
  if: always()
  run: |
    rm -f ~/.oci/key.pem ~/.oci/config
    rmdir ~/.oci 2>/dev/null || true
